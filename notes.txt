normal shadowpass

v2f vert(appdata_base v)
            {
                v2f o;
                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
                return o;
            }

just do your custom vertices before that and it will work:

v2f vert(appdata_base v)
            {
                float4 worldPos = mul(_Object2World, v.vertex);
                // do stuff to worldPos.xyz
                v.vertex = mul(_World2Object, worldPos);
                v2f o;
                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
                return o;
            }

here, he is turning the vertices to world coordinates and then back to object coordinates.
_Object2World is M matrix as I understand it.
so we're taking model coordinates * M to get their position in world space.

TRANSFER_SHADOW_CASTER_NORMALOFFSET

#define TRANSFER_SHADOW_CASTER_NOPOS(o,opos) 
o.vec = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz; 
opos = UnityObjectToClipPos(v.vertex);

so transfer shadow caster is taking object to world coordinates for the light position calculation,
then it sets position to UnityObjectToClipPos
This is the equivalent of mul(UNITY_MATRIX_MVP, float4(pos, 1.0)), and should be used in its place.

so clearly, TRANSFER_SHADOW_CASTER is assuming model vertices coordinates.

very similar to our billboard code, but the major difference is that in the sprite renderer,
we start from model vertices and want to end on clip coordinates, so we basically do
MVP * vertices
with some modification for billboarding

in the shadow caster example it's not as simple. we instead must start from model coordinates,
modify them to billboard, then return to model coordinates.


       M       V          P
model -> world -> camera -> clip space


possibility 1: do TRANSFER_SHADOW_CASTER_NORMALOFFSET manually with billboarding enabled.
possibility 2: perform some sort of billboarding in world space or whatever, then transform back.

billboard:

float xscale = length(unity_ObjectToWorld._m00_m10_m20);

float4 view = mul(
                UNITY_MATRIX_MV, 
                float4(0, vertex.y, 0.0, 1.0)
            ) + float4(vertex.x * xscale, 0.0, 0.0, 0.0);

pos = mul(
    UNITY_MATRIX_P, 
    view 
);

why does this work at all? we are basically multiplying the x coordinate straight from model to clip

✓ reformulate in 64x64
    ✓ new sprites
        ✓ base
        ✓ pistol
        ✓ smg
        ✓ shotgun
        ✓ rifle
    ✓ new models: not necessary
    ✓ new textures
        ✓ windows
        ✓ street parking sign
        ✓ gibs 
        ✓ shells
        ✓ decals
        ✓ newspaper stand
        ✓ sidewalk
        ✓ pc tower / monitor
        ✓ fence
        ✓ meter wires
        ✓ emission map

UI initiative
    probably i want pixelated / animated lines and callouts

interactible
    press F to interact with nearest 
    UI call-out of F action

how can we highlight when an object is near?
    needs to detect objects in range and sort by priority
        is this a case for a tag?
        a trigger collider, masked to collide with only certain layer objects
        what about don't hide interlopers?
    UI needs to bind to interactor

broadly:
interactive interface is in place.
we next need to think about how hacking interacts with this system.

* graphics
    pass 2 of base template
    security guard
    face
* UI   
    better gun / item graphics
* hacking
    networks / gateways / endpoints
    UI overlay
    clarity 
* level parameters
    sound effects, camera defaults, etc.
    scenes
    objectives
* system
    main menu
    game start
    game load
    settings
* entities
    baddies
    civilians
    robots
    AI
* more environment



time to speculate on some new gameplay beats. try to narrow in on what drew me to this idea.
overall theme possibilities:
    1. realistic B&E simulator. buildings have realistic utilities, firefighter access, security grids, physical security. you need specialized tools and tactics to get around.
    2. modern setting / cyberpunk setting / sci-fi setting
        shadowrun SNES: alleyways, brick buildings
    3. stealth ninja
        stealth kills with sword, knife, etc.
    4. whatever DJ1 was
            DJ1 was: flat concrete plains with small buildings dotting it. like military compounds.
            instead we want:
                self contained small office tower (say 3 story building) with interior, exterior, multiple insertion / extraction points.

inspo:
    ghost in the shell

the basic loop: do missions, earn credits, buy upgrades, do harder missions
    some very hard missions might be available early on, technically doable with pure stealth?

an alarm is triggered and the street fills up with private securiy swat response team (configurable offsite secutiy detail per level)
    the team lines up outside and then breaches through main entrance
an alarm is triggered and shutter doors descend, corridor fills with gas, turrets pop out of walls

you sneak through a ventilation airduct until you're above the conference room containing your target, bypassing the security detail and locked door outside.
you drop down through the vent and quickly dispatch everyone inside with throwing stars and nanoblade katana. the guards outside the door hear nothing and you commence extraction.
outside the window, the city night twinkles like fireflies in the darkness. your home is down there: safely in the shadows.

breaching a conference room, shooting the target with delayed-explosive tip flechettes

shellfish toxin flechettes / needlegun

you plant remote detonation explosives outside a wall in the alley way first thing, so that you'll have a quick escape route later. after you have completed the mission objectives, security is closing in:
so you hit the detonator and make for the hole in the wall.

planting explosives or a simulator / distractor outside, to draw the security team away from your target.

a team of two men in hazmat suits carry a radioactive thing through a cleanroom hallway

MI CIA NOC list sequence (disguise, trigger alarms, distract, track, etc.)

at the first sign of trouble, a team of bodyguards shove the VIP into a bulletproof limo and then take defensive positions

you approach a smart gas meter. interact brings up a live close-up cam with greater detail. you use a toolbox of tools to unscrew faceplates,
snip wires, attach hacking gizmos, enter the network, etc.

randomized missions

hack or tap security system to get a UI feed of their info & actions

shooting out a fine wire zipline into the neck of a distracted robot to upload a stun program that disables it temporarily

remote hacker handles hacking things for you
a fence for handling stolen goods & data

ransacking storage for valuable equipment?

overall, a sense of *precision and detail*

something like: hitman, but *not* scripted predetermined bullshit! instead, planning ahead, using an array of tools, realistic tactics, planning entrance and escape routes,
using what you've unlocked to access better ingress points (grapple gun, dropship), in a sort of immersive sim that takes care of realistic response to your actions.
each time it unfolds differently.
realistic security response.
    * something is amiss on the secutity cam (body, missing guard)
    * a guard has been out of communication for some time
    * perimiter alarm has been triggered

ironman mode?
abort mission?



incongruities with vision:
1. control 
    feels too loose?
    sticky controls: actual unity bug, submit bug report
2. shadows
    shadows should be more congruent with expected feel
    shadows on sprite should be darker
    easy to hide in, like thief
        use shadowprobe to create a transparent overlay?
        prevents nice dynamic shadows / light effects?
    i want deep shadows near planters and structures
        dark, gritty
        shadows don't apply correctly
        shadow probe doesnt change much in dark regions
    post-processing: increase contrast? dynamic?

head:
1. clamp head angle
2. don't apply head angle when moving
3. hide during forbidden animations
4. adjust gun spritesheets



ENUM            clamp       result
0 - left                    0
1 - leftup      X           1 <- clamp
2 - up                      2
3 - rightup                 3 <- upper
4 - right                   3
5 - rightdown               3/7
6 - down                    7
7 - leftdown                7 <- lower (-1)

7 - 4 = 3
3 / 2 = 1.5


ENUM            clamp       result
0 - left                    2/6
1 - leftup                  2
2 - up                      2 <- lower
3 - rightup                 3
4 - right       X           4 <- clamp
5 - rightdown               5
6 - down                    6 <- upper
7 - leftdown                6



ENUM            clamp       result
0 - left         X          0 <- clamp
1 - leftup                  1
2 - up                      2 <- upper
3 - rightup                 3
4 - right                   3/6
5 - rightdown               6
6 - down                    6 <- lower
7 - leftdown                7


next major branches to work on:

NPCs
    sphere robot
    basic civilians
        hands up pose
        animation temp frame
            hand interact pose
        damage
        gibbing
interactives
    PIP camera for panel interactions system
        take control mode
        layer visible only to cinematic camera
        camera lerp in / out on enter/exit
        UI contains PIP camera while active
        modular interactive panel system
            tool kit
                screwdriver, lockpicks, wire cutters, cyberdeck
            open up panel
            wires to cut
            data port to tap
            physical locks
            variable effects
                overload, bypass, reroute, etc.
                terminator-style hack card for ATM
environmental systems
    power
        lights, various gadgets receive power / no power
        dynamic lights / instanced material emission
        backup generator
        mains connection / transformer
        underground cables / steam tunnels
        UI representation of power network?

    network
        hacking system
            WAN / cloud connection on map
        allow hacking over networks
        routers / portals
        firewalls
        ICE
    alarms / video feed ?
    water / fire suppression ?

    represent the connections physically in-game
        automatically represent the connectors as meshes in-game?
        different vision modes can reveal infrastructure connections
        connections are severed when wall explodes
            water pipes spill water
            network connections severed
police / security response


camera
broadly, inputs are created depending on state, then camera applies input by lerping


1. on power change
2. power source on / off
3. easier way to hook up power grids
4. power grid UI layer
    iconography

Under the name ‘Livre des figures hiéroglyphiques’ The depictions were meant to be painted on an arch in Cimetière des Innocents. 
These depictions were inspired by the “strange figures” engraved in the mysterious manuscript that helped Flamel on the quest for the Philosopher’s Stone.


onpowergraphchange is not registered when level starts.


does everything connect back everywhere back to a single mains connection?
or do we implement several smaller connected graphs within each scene
    this is more game-like

how did i envision the transformer connecting to the mains connection?
normal nodes in the network do not block transmission when they are destroyed, otherwise blowing up a gun turret might take out lights.
but, i do want blowing up the transformer to take out the lights.
so there is a distinction:
    * regular node
    * distribution node 
    * switch
    * mains

how do i envision "power map view"?
    a separate view superimposed over the scene
    in analogy with similar views: network, water, sensor nets
    when the view is active, mouse over components to view their information
        * power: on / off
        * enabled: yes / no
        * information: when this node is disabled, it will no longer distribute power to connected components
    mouse becomes a cursor
        this is important for network / hacking view, too
    is there a better / more visual / more intuitive way to represent the flow of power then?
        simple connections in the network are not sufficient?
        or else: all connections *are* power connections. no serial between disconnected nodes.
            in other words, go back to the original design of nodes interrupting power flow
            this design will be very spoke & wheel
            we can always move the lines around
    when does the view activate?


is there an exclusive cursor mode when the item is deployed?
    cyberdeck yes, AR goggles no?
    how to communicate to player that they can't shoot now?

design for cyber networks
    does hack originate from offscreen, as original idea?
        that was so that you could hack the building before going in.
        could offer a chanc


separate the player input / character controller setinput into interfaces
the other part of this code is pushing updates to animation - we can refactor this to use MVC / binding

unify sphereRobotAnimation and DirectionalBillboard
flip x in directional billboard

* head alignment
* wallpress camera alignment
* manual hacker
* fix binding to global player object
* wallpress zoom out
* jump controller

during slew time:
    turn to look
    don't shoot

searching:

1. looking in a direction versus searching a point
2. time evolution

looking in a direction:
    1. slew / look in direction
    2. look left, look right
    3. move some distance from original point towards the direction
    4. arrive at location, stop
    5. look left, look right

searching a location
    1. slew / look towards location
    2. move to location
    3. arrive at location
    4. look left, look right
    5. choose a new location near original location
    6. repeat 2-5

radioing to HQ
    1. find cover
    2. move
    3. operate radio
    transition to:
        player location unknown: search
        player location known: attack

we want to queue / schedule several routines in order, with transitions governed by timers or behavior
routines should have an update cycle and a way to check completeness
do we have a routine stack? what about branching?
more complex behavior would have the ability to transition to different routines depending.
    this makes it sound like routine logic controls the transition to the next routine.
    is the routine pushing this information or is it being polled by the state machine?

routine can publish when they are done
routine can publish transition to new state?

Q: levels:
1. individual routines (move, slew, etc)
2. overall state machine states (search direction, search location, radio hq)
3. state machine. time since last seen player, component references

something like: nested structure. update method, complete method
    method can publish finished, or transition to state

overhaul everything to be a behavior tree.
now we have to think: how is perception / sound going to be handled.
    1. use the tree logic and / or to handle perception states
    2. user perceptions to change textures

the question is: what do the state machine states correspond to?
it feels like they should be trees. recast the sequence as tree.


1. task tree updating
2. timed look toward task
3. timed look left / look right
4. retreiving player input from task

timed should become a decorator
use the namespace



major issue:
Evaluate() was the main chained thing that called sub nodes in the tree.
but Evaluate() isn't enough? Evaluate() returns a status, but I also need there to be a current active node 
findable from the root that is in control and returns PlayerInput.

return to using Evaluate()
but now the running node needs to somehow give playerinput
a timer decorator runs the child node and returns Running until time up
sequence is handled by a Sequence node

Evaluate takes a ref value
does Evaluate happen in an Update loop?

possibly, a Reset() mode but resetting can be handled by instantiating new state machine state

1. how to turn navigation etc. into task node

how to handle dynamic state in the behavior tree?
the normal solution seems to be to publish data to/from the tree. this feels clunky to me.
Ref<> is interesting.
TaskStatus<T>
TaskStatus(Owner)

what is the desired behavior?
1. look left, look right, move in. look around. move to a new spot? 
    if a new noise is heard, skip looking and move to that spot.
    how do we retarget? in behavior tree mode, it should look like:
    1. start path search aynchronous, running
    2. when path is found, next in sequence: move to target
    3. if path is not found, failed.

add movement to the root node sequence, but we're already off track:
1. resetting root node resets the entire sequence
2. not easy to retarget position without resetting root node.

how about: stop fighting the jank and use the getstate methods? it is the standard for behavior trees?
1. magic strings
2. unchecked casting (no strong)

TaskNode<T>(T context) where T: TaskNodeContext
then we can pass in 

playerinpu ref might be a bad idea?

now that we have that settled, the question is how to how to arrange the search AI as a behavior tree

the look-around branch is timer controlled. it consists of a sequence of timer controlled look directives.
    when to reset this timer? storing the timer in state allows for resetting? 
    recreating the branch each state change results in look-around loop?
        this is less important, we can have good control over state transition

sequence:
1. pathfind
2. navigate
have a Reset() method

sequence
1. move to key
2. select new random location for key
timer decorator involved?
timer decorator reset with repeater?

clean up and refactor and unify tasks
    unite all move to tasks
    remove reset?
    parent set data?

tune up ai behaviors
    1. add a delay to movement
        1. constantly changing target location while sphere is at old location until location is updated
        2. timer decorator will still be successful on the next time around 
    2. search more locations in noise?
    3. attack


visibility solutions

visibility shadows
    1. we must set texture orientation
    2. applying a shadow to the entire sprite is at odds with nice light effect
    3. combine regular shader and an overlay texture?
visibility rating
    1. use camera / vis probe surface as usual
        problem: shadows don't quite match up with expectations.
        can we make the solution more complex?
    2. use light probe
        problem: only works for baked lightmaps
    3. hand paint texture
        problem: immediacy of editing
        investigate editing texture in editor
        investigate terrain setting
    4. terrain
        can use in-editor painting
        can retrieve texture mix at point
        use this method for 

using terrains seems like an ideal solution for representing ground information
issues:
    1. discrete shadow levels (like thief)
        multiple textures?
        two textures with varying opacity?
            it is hard to control the opacity in editor
            hard to control precise boundaries
        multiple textures
            more work as more textures are added
            can use 3 textures plus overlap:
                shadow, mid, light


if (textureValues[0] > 0)
{
    source.PlayOneShot(GetClip(stoneClips), textureValues[0]);
}
if (textureValues[1] > 0)
{
    source.PlayOneShot(GetClip(dirtClips), textureValues[1]);
}
    

100 * ((0.2126 * 255) + (0.7152 * 255) + (0.0722 * 255))
255
25500 = 100 

100 * ((0.5 * 255) + (0.5 * 255) + (0.5 * 255))
38250


100 * ((0.5 * 255) + (0.5 * 255) + (0.2 * 255))
30600


20 = ++
30 = +++
40 = +++
45 = ++++
60+ = +++++


3 vs 10
B < 10: -
10 < B < 15: +
15 < B < 30: ++
30 < B < 60: +++
60 < B < 80: ++++
80 < B : +++++



set billboard
set albedo = white pixel
set emission
    emission map: single pixel white
    emission color: white + intensity 2
    emissio


1. put suspicion warnings as icons on bottom of screen in line with visibility indicator
    overall color and eye-catch can alert player on the fly


suspicion UI handler binds to GameManager
GameManager publishes when player suspicion changes
this will push updates to the various UI components
this could trigger an outline flash


1. billboarded color outliner
2. handle transitions between suspiciousness 
fix audio suspicion
